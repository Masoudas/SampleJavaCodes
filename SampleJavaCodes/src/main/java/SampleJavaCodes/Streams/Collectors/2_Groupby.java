package SampleJavaCodes.Streams.Collectors;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class Person {
    String name;
    int id;

    public Person(String name, int id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }
}

/**
 * Let's first discuss the function interface, Well Function<U,V> accepts an
 * argument of type U, and returns a type V.
 */
class FunctionImplementer implements Function<Object, Void> {

    @Override
    public Void apply(Object t) {
        return null;
    }

}

/**
 * Now, the simplest groupby takes only a classifier. It then creates a map that
 * contains as key the classified elements, and a List that corresponds to
 * elements of stream that correspond to that key. Obviously, the classifier
 * method is a Function interface that takes as input elements of the stream and
 * returns some measure of grouping type. So all the elements of stream that
 * return the same output with the function interface are grouped together.
 */
class SimplestGroupBy {
    public static void main(String[] args) {
        Person[] persons = { new Person("a", 1), new Person("a", 2), new Person("b", 3) };

        Map<String, List<Person>> peopleWithSimilairNames = Stream.of(persons)
                .collect(Collectors.groupingBy(Person::getName));

        System.out.println(peopleWithSimilairNames);
    }
}

/**
 * The second grouping method, allows us to do another collection method on
 * elements that are grouped together (called downstream collector, because it's
 * downstream of collect). So let's say in the following example, we have two
 * Persons associated with one key. We then supply a toSet to collect them as
 * set instead of List.
 */
class GroupByWithDownStreamOperation {
    public static void main(String[] args) {
        Person[] persons = { new Person("a", 1), new Person("a", 2), new Person("b", 3) };

        Map<String, Set<Person>> peopleWithSimilairNames = Stream.of(persons)
                .collect(Collectors.groupingBy(Person::getName, Collectors.toSet()));

        System.out.println(peopleWithSimilairNames);
    }
}

/**
 * The third method allow us to provide a map factory for the type of HashMap
 * that is generated by the groupingBy method.
 * 
 */

class GroupbyWithAMapFactory {
    public static void main(String[] args) {
        Person[] persons = { new Person("a", 1), new Person("a", 2), new Person("b", 3) };

        HashMap<String, Set<Person>> peopleWithSimilairNames = Stream.of(persons)
                .collect(Collectors.groupingBy(Person::getName, HashMap::new, Collectors.toSet()));

        System.out.println(peopleWithSimilairNames);
    }

}