package SampleJavaCodes.Generics.TypeErasure;

/**
 * As we mentioned, a generic class or interface is treated as a normal class.
 * Question is, what happens when we inherit the class, or implement the
 * interface? (This interface part is my thought, I could be wrong, but I don't
 * think so. Because interface is probably a class with all methods public
 * abstract and private constructor).
 * 
 * We see that in the main, the i_raw holds a raw type reference to
 * ImplementerI. Now, this method is set(Object), but it's part of the class.
 * The point is that when we implement the interface, we inherit the
 * set(Object), because after all, the GenericI interface is implemented with
 * Object at compile time. In summary, ImplementerI has two methods, set(Object)
 * and set(Integer). This way, polymorphism is preserved. Now, to make sure that
 * the set Object method does the same thing as set Integer, the compiler
 * creates a bridge method, which is just set(Object t){ val = (Integer)t}. This
 * is why we can't get cheeky and assign string here!
 * 
 */
interface GenericI<T> {
    public void set(T t);
}

class ImplementerI implements GenericI<Integer> {
    Integer val;

    @Override
    public void set(Integer t) {
        val = t;
    }

    public static void main(String[] args) {
        ImplementerI i = new ImplementerI();
        GenericI i_raw = i;
        i_raw.set("value"); // This line throws a class cast exception at runtime of course.

    }
}

/**
 * Now, the same situation happens with classes and inheritance. Consider the
 * following from official oracle documentation.
 * 
 * Again here, a bridge method for the inherited class is created as:
 * 
 * // Bridge method generated by the compiler
 * 
 * public void setData(Object data) { setData((Integer) data); }
 */
class InheritNode<T> {

    public T data;

    public InheritNode(T data) {
        this.data = data;
    }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

class MyNode extends InheritNode<Integer> {
    public MyNode(Integer data) {
        super(data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    public static void main(String[] args) {
        MyNode mn = new MyNode(5);
        InheritNode n = mn; // A raw type - compiler throws an unchecked warning
        n.setData("Hello"); // Causes a ClassCastException to be thrown.
    }
}
